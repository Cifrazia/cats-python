# Protocol v2.0

## Client

Minimal client protocol version: `2.0`

## Statement

=== Client statement

+++ JSON

```json5
{
  // Version of API (not protocol)
  "api": 0,
  // Client local time in ms
  "clientTime": 16500123000,
  // Which format to use for object encoding: JSON | YAML | TOML
  "schemeFormat": "JSON",
  // Compression algorithms, supported on client side: gzip | zlib
  "compressors": [
    "gzip",
    "zlib"
  ],
  // Optional. compressors[0] used by default
  "defaultCompression": "zlib",
}
```

+++ YAML

```yaml
api: 0
clientTime: 16500123000
schemeFormat: JSON
compressors:
  - gzip
  - zlib
defaultCompression: zlib
```

+++ TOML

```toml
api = 0.0
clientTime = 16500123000.0
schemeFormat = "JSON"
compressors = [
  "gzip",
  "zlib"
]
defaultCompression = "zlib"
```

+++

=== Server statement

+++ JSON

```json5
{
  // Server local time in ms [UTC]
  "serverTime": 165000123000,
}
```

+++ YAML

```yaml
serverTime: 165000123000
```

+++ TOML

```toml
serverTime = 165000123000.0
```

+++

===

## Actions

### `0x00` Action

[!button icon="package" variant="contrast" corners="square" text="Head" margin="0 4 4 0"]
[!button icon="package" variant="contrast" corners="square" text="Headers" margin="0 4 4 0"]
[!button icon="package" variant="contrast" corners="square" text="Payload" margin="0 4 4 0"]

Common request/response action.

#### Head

+ **Handler ID**: `uInt2` - [Endpoint ID](#endpoints) - treat as URL alternative
+ **Message ID**: `uInt2` - [Message ID](#message-id)
+ **Send Time**: `uInt8` - Client send time in ms
+ **Data Type**: `uInt1` - What [type](#data-types) **PAYLOAD** is
+ **Compression**: `uInt1` - What compression was used on **PAYLOAD**
+ **Data Len**: `uInt4` - Length of **HEADERS** + **HEADER_SEPARATOR** + **PAYLOAD**

#### Headers

Message header works like in HTTP: It contains META information that can be used at protocol level to change up server
behavior w/o changing business logic.

Message header is a simple `UTF-8` encoded JSON (YAML or TOML) dictionary followed by two empty bytes `00 00`

**Request only Headers**

- `"Offset": int` [1] - tells the server to skip N amount of first bytes of `<Data>` section

**Response only Headers**

There are no response-only header currently supported

**Common Headers**

- `"Files": [{"key": str, "name": str, "size": int, "type": str?}]` [1] - This header is being used when `<Data Type>`
  in packet header is set to `FILES - 0x02`
- `"Status": int` - HTTP Status code analog. Usually only used by a server to show client if there was any error or not.

> **[1]** Using "Offset" header for the handler that returns `FILES` will also decrease "size" fields in "Files" response header.
> If "size" will drop to zero, then file won't appear in "Files" header.

#### Payload

Whatever `Handler` accepts/returns

## Endpoints

In HTTP servers, endpoints are functions, that are located with `method: GET|POST|etc.` and `URL: https://...`. In **
CATS** we use `uInt2` ID to locate endpoints.

Endpoints are triggered with `Action` and `StreamAction` messages, and they can ask issuer for additional info
using [Inputs](#inputs)

## Message ID

Message ID - is `uInt2` random number, generated by sending party. It is used to track `request-response`.

+ Message ID must be unique for active requests
+ Message ID must be `0x0000` to `0x7FFF` for `request-reply` scenario
+ Message ID must be `0x8000` to `0xFFFF` for `broadcast/publish` scenario
+ You may use increment counter or RNG to generator Message ID
+ Response will contain the same `Message ID` as request

## Data Types

### `0x00` Binary

Plain byte buffer, how to use/parse it, should be described in [API endpoint](#endpoints) description

### `0x01` Scheme

JSON (YAML or TOML) encoded object. Which format is used declared at [initialisation stage](index.md#initialisation)

### `0x02` Files

One or multiple files, concatenated together in a single byte buffer. Information about their respective sizes, names,
formats, etc. is located in **HEADERS**

+++ JSON

```json5 Headers
{
  // List of files (order is same as byte buffers in payload) 
  "Files": [
    {
      // Hashmap key, may equal to name
      "key": "avatar", 
      // Selected file name
      "name": "Anakin.jpg",
      // Size of byte buffer, that went into payload
      "size": 51231, 
      // MIME (optional)
      "type": "image/jpeg",
    },
    // ... more files
  ]
}
```

+++ YAML

```yaml Headers
Files:
  - key: avatar
    name: Anakin.jpg
    size: 51231
    type: image/jpeg
```

+++ TOML

```toml Headers
[[Files]]
key = "avatar"
name = "Anakin.jpg"
size = 51231.0
type = "image/jpeg"
```

+++

!!!
If payload was cut with `Offset` header, `Files[n].size` will be reduced as well.
!!!

### `0x03` Byte Scheme

Custom data scheme, encoded in plain bytes (like [action head](#head))